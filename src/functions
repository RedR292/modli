##Installs a mod to the modli system.
##DOES NOT ADD MOD TO A STAGE FILE
install() {
	local mod
	if [[ -z "$MOD" ]]; then
		echo -n "Enter the mod's directory (filepath): "
		read MOD
	fi
	if [[ -z "$MOD" ]]; then
		echo "modli: ERR: NO MOD PASSED. ABORTING INSTALLATION" >&2
		return 1
	fi
	##User input to rename mod
	echo "modli: Installing $(basename "$MOD") to modli."
	echo "Rename the file and press enter. Raw mods must end in .7z and install scripts must end in .sh."
	echo "Leave this blank if you don't want to change the name."
	echo -n "Rename file to: "
	read mod
	##User didn't rename the mod
	if [[ -z "$mod" ]]; then
		mod="$(basename "$MOD")"
	fi

	##Installing a mod
	##TODO: use diff to find the same file under a different name
	if [[ "$mod" == *.7z ]]; then
		if [[ -f "$GAME_PATH/Mods/$mod" ]]; then
			echo "modli: $mod was already installed. Aborting install"
			return 0
		fi
		##Check if MOD can be installed directly
		checkTrivialMod
		if [ $? -eq 1 ]; then
			return 1
		fi

		##Check if mod is allowed (see: `modli -h "<GAME_NAME>"` for more info)
		local status
		validatemod
		status=$?
		if [ $status -eq 1 ]; then
			echo "modli: ERR: $(basename "$MOD") IS NOT A 7z ARCHIVE." >&2
      return 1

		elif [ $status -eq 2 ]; then
			echo "modli: ERR: $(basename "$MOD") HAS MORE THAN ONE ROOT DIRECTORY" >&2
			return 1

		elif [ $status -eq 3 ]; then
      echo "modli: ERR: $(basename "$MOD")'s ROOT DIRECTORY NOT NAMED 'Data'" >&2
      return 1
		fi

		mv "$MOD" "$GAME_PATH/Mods/$mod"
		echo "modli: $mod has been installed to $GAME_PATH"
	##Installing a script
	elif [[ "$mod" == *.sh ]]; then
		if [[ -f "$GAME_PATH/Scripts/${mod%.*}/$mod" ]]; then
			echo "modli: $mod already exists. Aborting installation"
			return 0
		fi
		mkdir -p "$GAME_PATH/Scripts/${mod%.*}/Data"
		mv "$MOD" "$GAME_PATH/Scripts/${mod%.*}/$mod"
		echo "Enter the directory of the mod and/or data to go with the script. If no data is needed, press enter to skip.
		WARNING: scripts are not validated by modli. Best practices are recommended when writing your own scripts
		Proceeding means the user understands the risks of a poorly written script, such as corrupted, missing and/or unchecked data."
		local datadir
		echo -n "Enter the new name: "
		read datadir
		if [[ ! -z "$datadir" ]]; then
			mv "$datadir"/* "$GAME_PATH/Scripts/${mod%.*}/Data/"
		fi

		echo "modli: Script $mod was installed to $GAME_PATH/Scripts/${mod%.*}"

	else
		echo "modli: ERR: $(basename "$mod") must end in .7z or .sh. Aborting installation" >&2
		return 1
	fi

	echo "modli: $MOD was installed"
	return 0
}

##Removes a mod from modli
##Could break a lot of stuff if not done right.
##TODO: Remove mods from games. Detect if the stage file is launched?
uninstall() {
	local mod
	mod="$MOD"
	if [ -z "$mod" ]; then
		ls -p "$GAME_PATH/Mods/" | grep -v /
		echo Enter the name of the mod you would like to remove:
		read mod
	fi
	if [[ ! -f "$GAME_PATH/Mods/$mod" ]]; then
		echo modli: ERR: $mod not found >&2
		return 1
	fi
	rm "$GAME_PATH/Mods/$mod"
	echo "modli: $mod was succsessfully uninstalled"
	return 0
}

##executes a custom install script
runScript() {
	. "$GAME_PATH/Scripts/${MOD%.*}/$MOD"
	if [[ $? -ne 0 ]]; then
		echo "modli: ERR: $MOD was not executed properly" >&2
		return 1
	fi
	echo "modli: $MOD succsessfully executed"
	return 0
}

##Adds $MOD to $GAME_NAME stage file
addToStage() {
	local mod
	ls -p "$GAME_PATH/Mods/" | grep -v /
	echo "Enter the name of the mod you would like to add to $GAME_NAME's stage file"
	read mod

	##If mod was not found
	if [[ ! -f "$GAME_PATH/Mods/$mod" ]]; then
		echo "modli: ERR: $mod not found" >&2
		return 1
	fi

	##Create a stage if it does not already exist
	if [[ ! -f "$GAME_PATH/stage.tar" ]]; then
		cd "$GAME_PATH/Mods/" > /dev/null
		tar cf "$GAME_PATH/stage.tar" "$mod"
		cd - > /dev/null

	##If mod already exists in stage
	elif [ "$(tar tf "$GAME_PATH/stage.tar" | grep "$mod")" ]; then
		echo "modli: $mod is already in $GAME_NAME's stage"
		return 0
	#Archives the mod into the stage
	else
		cd "$GAME_PATH/Mods/" > /dev/null
		tar rvf "../stage.tar" "$mod"
		cd - > /dev/null
		echo "ready" > "$GAME_PATH/stage.status"
		echo "modli: $mod was added to $GAME_NAME's stage"
	fi
	return 0
}

##Removes a mod from GAMEs stage file
removeFromStage() {
	local mod
	local results
	if [ "$(cat "$GAME_PATH/stage.status" | grep "launched")" ]; then
		echo "modli: WARNING: $GAME_NAME's stage is launched. Cannot remove from an actively launched stage. Aborting removal"
		return 2
	fi
	results=$(tar tf "$GAME_PATH/stage.tar")
	if [ -z "$results" ]; then
		echo "modli: WARNING: No mods currently staged. Aborting removal"
		return 0
	fi
	echo "Enter the name of the mod you want to remove from the list: "
	read mod
	if [ -z "$(echo $results | grep "$mod")" ]; then
		echo "modli: ERR: $mod was not found" >&2
		return 1
	fi
	tar --delete --file="$GAME_PATH/stage.tar" "$mod"
	results=$(tar tf "$GAME_PATH/stage.tar")
	if [ -z "$results" ]; then
		echo "empty" > "$GAME_PATH/stage.status"
	fi
	echo "$mod was removed from $GAME_NAME's stage file"
	return 0
}

##launches stage file to GAME
##This performs the BARE MINIMUM and needs to be implemented into each mod manager
Launch() {
	if [[ $(tar tf "$GAME_PATH/stage.tar" | wc -w ) -eq 0 ]]; then
		echo "modli: ERR: $GAME_NAME's STAGE FILE IS EMPTY." >&2
		return 1
	fi
	echo "Preparing to implement stage file to $GAME_NAME"
	mkdir -p "$root/tmp"
	tar xf "$GAME_PATH/stage.tar" -C "$root/tmp"
	for file in "$root"/tmp/*; do
		7z x "$file" -o"$root/tmp/" > /dev/null
		# echo "modli: installed $(basename "$file") to $GAME_NAME"
	done
	cp -r "$root/tmp/Data" "$GAMEPATH/"
	rm -rf "$root/tmp"
	echo "Launched on $(date +"%x %r %Z")" > "$GAME_PATH/stage.status"
	echo "modli: The stage has been launched to $GAME_NAME"
	return 0
}

##Removes a stage from GAME
##TODO: Refactor to work with games dynamically (currently only works for Fallout 4)
##The POTENTIALLY DANGEROUS COMMAND. Treat this line like you would info with a grain of salt.
##Command should treat mod files like subdirectories of game root
##find Data -type f -exec rm ~/.steam/steam/steamapps/common/Fallout\ 4/{} \;
Remove(){
	local contents
	mkdir -p "$root/tmp"
	tar xf "$GAME_PATH/stage.tar" -C "$root/tmp"
	# contents="$(tar tf "$GAME_PATH/stage.tar")"
	contents="$(ls "$root/tmp")"
	for file in "$root/tmp/"*; do
		7z x "$file" -o"$root/tmp/" #Should produce a single Data folder in root/tmp
	done
	cd "$root/tmp" > /dev/null
	# find Data -type f -exec ls "$GAMES"/Fallout\ 4/{} \;
	find "$root/tmp/Data" -type f -exec rm "$GAMES"/Fallout\ 4/{} \;
	if [[ -n $? ]]; then
		echo "modli: ERR: Cannot remove stage, issue in deleting files" >&2
		return 1
	fi

	##cleanup
	rm -rf "$root/tmp"
	cd - > /dev/null
	echo "modli: Stage has been removed"
	echo "ready" > "$GAME_PATH/stage.status"
	return 0
}

##Checks all available mods for GAME
checkAvailableMods() {
	local stageContents
	local modDirectory
	local results
	local mod
	mkdir -p "$root/tmp"
	if [[ ! -e "$GAME_PATH/stage.tar" ]]; then
		echo "modli: ERR: Stage has not been created yet. Please add a mod to generate the stage"
		return 1
	fi
	stageContents="$(tar tf "$GAME_PATH/stage.tar" | sort)"
	modDirectory="$(ls "$GAME_PATH/Mods/" | sort)"
	results="$(echo "$modDirectory" | grep -ev "$stageContents")"
	# results="$(diff "$stageContents" "$modDirectory")
	if [ -n $? ]; then
		echo "modli: WARNING: all installed mods are already added in the stage. Aborting check."
		return 0
	fi

	echo "Mods available to be added to $GAME_NAME's stage:"
	echo "$results"
	return 0
}

##Checks all currently installed mods for GAME
checkInstalledMods() {
	local stageContents
	if [[ ! -e "$GAME_PATH/stage.tar" ]]; then
		echo "modli: ERR: Stage has not been created yet. Please add a mod to generate the stage"
		return 1
	fi

	if [ -z "$(tar tf "$GAME_PATH/stage.tar")" ]; then
		echo "modli: No mods are staged to $GAME_NAME. Aborting check."
		return 0
	fi
	stageContents=$(tar tf "$GAME_PATH/stage.tar")
	echo "Mods currently staged to $GAME_NAME:"
	echo "$stageContents"
	return 0
}
